#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.9"
# dependencies = [
#   "lark"
# ]
# ///

# bndsl_parser.py
"""
A self-contained module for parsing the BN-DSL (BinaryNinja Domain Specific Language).

This module uses the Lark parsing library to parse a textual DSL into structured
Python objects (dataclasses). The DSL is designed for representing reverse
engineering annotations like function renames, variable renames, and comments
at specific addresses.

The DSL supports:
- FNAME <addr> <new_function_name>
- VNAME <addr> <old_var_root> <new_var_root>
- COMMENT <addr> @" any text, may span lines and include \"escaped quotes\" "
- Line comments starting with '#' within the DSL itself.

Requires the 'lark' library: pip install lark
"""

import dataclasses
from typing import List, Union, Any

# Lark-specific imports
# If you see "ModuleNotFoundError: No module named 'lark'",
# please install it: pip install lark
try:
    from lark import Lark, Transformer, v_args, Token
    from lark.exceptions import LarkError
except ImportError:
    print("Lark library not found. Please install it using: pip install lark")
    Lark = None
    Transformer = object  # type: ignore
    v_args = lambda *args, **kwargs: lambda f: f  # type: ignore
    Token = None  # type: ignore
    LarkError = Exception  # type: ignore


# --- Dataclass Definitions for DSL Commands ---
# These classes represent the structured form of each DSL command.


@dataclasses.dataclass
class CommentCommand:
    """Represents a COMMENT command in the DSL."""

    address: int
    text: str
    command_type: str = "COMMENT"


@dataclasses.dataclass
class FNameCommand:
    """Represents an FNAME (function rename) command in the DSL."""

    address: int
    new_name: str
    command_type: str = "FNAME"


@dataclasses.dataclass
class VNameCommand:
    """Represents a VNAME (variable rename) command in the DSL."""

    address: int
    old_var_root: str
    new_var_root: str
    command_type: str = "VNAME"


# Union type for type hinting a list of any command
DSLCommand = Union[CommentCommand, FNameCommand, VNameCommand]


# --- Lark Grammar Definition ---
# This EBNF-style grammar defines the syntax of the bn-dsl.
_BNDSL_LARK_GRAMMAR = r"""
    ?start: command* // The DSL is a sequence of zero or more commands

    // A command can be one of the following types
    command: comment_stmt
           | fname_stmt
           | vname_stmt

    // Structure of the COMMENT command
    // Example: COMMENT 0x1000 @"This is a
    // multi-line comment."
    comment_stmt : "COMMENT"i HEX_ADDRESS AT_STRING

    // Structure of the FNAME command
    // Example: FNAME 0x1000 process_data
    fname_stmt   : "FNAME"i HEX_ADDRESS IDENTIFIER

    // Structure of the VNAME command
    // Example: VNAME 0x1000 buffer_old input_buffer
    vname_stmt   : "VNAME"i HEX_ADDRESS IDENTIFIER IDENTIFIER

    // --- Terminal Definitions ---
    // Terminals are the basic building blocks (tokens) of the grammar.

    // HEX_ADDRESS: Matches hexadecimal numbers like 0x123ab, 0XDEADBEEF
    HEX_ADDRESS: /0x[0-9a-fA-F]+/

    // IDENTIFIER: Matches typical variable/function names (snake_case, etc.)
    // Starts with a letter or underscore, followed by letters, numbers, or underscores.
    IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_]*/

    // AT_STRING: Matches strings enclosed in @".
    // Supports multi-line content and escaped characters like \" or \\.
    // Example: @"This is a string\nIt can span lines and have \"escaped\" quotes."
    AT_STRING : /@"(?:\\.|[^"\\]|\n)*"/

    // --- Ignored Tokens ---
    // These tokens are ignored by the parser (whitespace, DSL comments).

    // Import common whitespace (spaces, tabs, newlines)
    %import common.WS
    // Ignore whitespace between tokens
    %ignore WS

    // Ignore DSL comments: lines starting with '#'
    %ignore /#[^\n]*/
"""


# --- Lark Transformer ---
# This class transforms the parse tree generated by Lark into our dataclasses.
# Each method corresponds to a rule in the grammar.
class DslToDataclasses(Transformer):
    """
    Transforms the Lark parse tree into a list of DSLCommand dataclass instances.
    """

    def HEX_ADDRESS(self, token: Token) -> int:
        """Converts a HEX_ADDRESS token to an integer."""
        return int(token.value, 16)  # token.value is the matched string

    def IDENTIFIER(self, token: Token) -> str:
        """Returns the string value of an IDENTIFIER token."""
        return str(token.value)

    def AT_STRING(self, token: Token) -> str:
        """
        Processes an AT_STRING token.
        It strips the surrounding @" and " from the captured string.
        The content may include newlines and escaped characters.
        """
        # The token.value includes the @", so we strip it and the final quote.
        return token.value[2:-1]

    # The @v_args(inline=True) decorator unpacks child nodes directly
    # as arguments to the transformer methods.
    # The method name (e.g., comment_stmt) matches the rule name in the grammar.

    @v_args(inline=True)
    def comment_stmt(self, address: int, text: str) -> CommentCommand:
        """Creates a CommentCommand from parsed components."""
        return CommentCommand(address=address, text=text)

    @v_args(inline=True)
    def fname_stmt(self, address: int, new_name: str) -> FNameCommand:
        """Creates an FNameCommand from parsed components."""
        return FNameCommand(address=address, new_name=new_name)

    @v_args(inline=True)
    def vname_stmt(
        self, address: int, old_var_root: str, new_var_root: str
    ) -> VNameCommand:
        """Creates a VNameCommand from parsed components."""
        return VNameCommand(
            address=address, old_var_root=old_var_root, new_var_root=new_var_root
        )

    def start(self, items: List[DSLCommand]) -> List[DSLCommand]:
        """
        Processes the top-level 'start' rule.
        Since 'start: command*' produces a list of processed 'command' items,
        this method typically just returns that list.
        """
        return items


# --- Main Parsing Function ---
_parser_instance = None
_transformer_instance = None


def _get_parser_and_transformer():
    """Initializes and returns the Lark parser and transformer instances (singleton)."""
    global _parser_instance, _transformer_instance
    if Lark is None:  # Check if Lark failed to import
        raise RuntimeError(
            "Lark library is not available. Please install it: pip install lark"
        )
    if _parser_instance is None:
        _parser_instance = Lark(
            _BNDSL_LARK_GRAMMAR,
            parser="earley",  # Earley is robust and handles ambiguities well.
            propagate_positions=True,  # Useful for error reporting with line/column numbers.
            lexer="dynamic",  # Changed from 'standard' to 'dynamic' for Earley compatibility
        )
    if _transformer_instance is None:
        _transformer_instance = DslToDataclasses()
    return _parser_instance, _transformer_instance


def parse_bndsl(dsl_string: str) -> List[DSLCommand]:
    """
    Parses a BN-DSL string and returns a list of DSLCommand objects.

    Args:
        dsl_string: The string containing the BN-DSL to parse.

    Returns:
        A list of DSLCommand dataclass instances representing the parsed commands.

    Raises:
        LarkError: If there's a syntax error or other parsing issue in the dsl_string.
                   This can be LarkError, ParseError, VisitError, etc.
        RuntimeError: If the Lark library is not installed/available.
    """
    if not isinstance(dsl_string, str):
        raise TypeError("Input dsl_string must be a string.")

    parser, transformer = _get_parser_and_transformer()

    try:
        parse_tree = parser.parse(dsl_string)
        transformed_commands: List[DSLCommand] = transformer.transform(parse_tree)
        return transformed_commands
    except LarkError as e:
        raise e


# --- Example Usage (when run as a script) ---
if __name__ == "__main__":
    print("BN-DSL Parser Module - Example Usage (with @-string comments)")
    print("----------------------------------------------------------")

    if Lark is None:
        print("Cannot run example: Lark library is not installed (pip install lark).")
    else:
        example_dsl = """
        # This is a DSL comment and should be ignored by the parser.
        FNAME   0x006ebf00 check_and_load_license
        COMMENT 0x006ebf00 @"Entry: verify or load license blob.
        This can span multiple lines."

        # Another DSL comment
        COMMENT 0x006ebf58 @"Early-out if license already validated."
        VNAME   0x006ebf64 user_buf license_env_buffer # Inline DSL comment, also ignored

        # Test case sensitivity for keywords (should still work)
        fname   0x12345 TestFunction
        CoMmEnT 0xABCDE @"Testing case insensitivity for keywords."
        """

        empty_dsl = ""
        comments_only_dsl = """
        # Comment 1
        # Comment 2
        """
        malformed_dsl = """
        FNAME 0x1000 # Missing name
        COMMENT not_an_address @"text"
        INVALID_COMMAND 0x2000
        COMMENT 0x3000 @Unclosed string
        """

        test_cases = [
            ("Valid DSL", example_dsl),
            ("Empty DSL", empty_dsl),
            ("Comments Only DSL", comments_only_dsl),
        ]

        for name, dsl_content in test_cases:
            print(f"\n--- Testing: {name} ---")
            print("Input DSL:")
            print(f"```\n{dsl_content.strip()}\n```")
            try:
                parsed_commands = parse_bndsl(dsl_content)
                if parsed_commands:
                    print("\nParsed Commands:")
                    for cmd in parsed_commands:
                        # For printing, show escaped newlines to keep output clean
                        escaped_cmd_text = (
                            cmd.text.replace("\n", "\\n")
                            if isinstance(cmd, CommentCommand)
                            else None
                        )
                        print(
                            f"  {dataclasses.replace(cmd, text=escaped_cmd_text) if escaped_cmd_text else cmd}"
                        )
                else:
                    print(
                        "\nNo commands parsed (input might be empty or comments only)."
                    )
            except LarkError as e:
                print(f"\nError parsing DSL: {e}")
                # For more detailed error, Lark's error objects have attributes like:
                # print(f"  Line: {e.line}, Column: {e.column}")
                # print(f"  Context: {e.get_context(dsl_content, context_lines=2)}")
                # print(f"  Expected: {e.expected}")
            except Exception as e:
                print(f"\nAn unexpected error occurred: {e}")

        print(f"\n--- Testing: Malformed DSL (expecting errors) ---")
        print("Input DSL:")
        print(f"```\n{malformed_dsl.strip()}\n```")
        try:
            parsed_commands = parse_bndsl(malformed_dsl)
            print("\nParsed Commands (should not happen for malformed):")
            for cmd in parsed_commands:
                print(f"  {cmd}")
        except LarkError as e:
            print(f"\nSuccessfully caught LarkError as expected:")
            print(f"  Error: {e}")
        except Exception as e:
            print(f"\nAn unexpected error occurred: {e}")

        print("\n--- End of Examples ---")
